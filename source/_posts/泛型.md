---
title: 泛型
date: 2022-04-02 14:23:32
tags: [Java, 泛型]
index_img: /img/T.png
categories: Java

---



<p class="note note-info">泛型程序设计分为三个能力水平，基本水平是仅仅使用泛型           --《Java核心技术卷Ⅰ》</p>

<!-- more -->



## 什么是泛型

Java 5 中引入了泛型这个重要的概念,提供了编译时类型安全监测机制,泛型的本质就是**参数化类型**,也就是说所操作的数据类型被指定为一个参数。

**早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题,例如集合操作**

**Java泛型设计原则：**只要在编译时期没有出现警告，那么运行时期就不会出现**ClassCastException(类型转换异常)**异常

**泛型：**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型

**优势:**

- 类型安全
- 消除了强制类型的转换



## 泛型类、接口



### 泛型类

**语法：**

```java
class 类名称<泛型标识，泛型标识，...>{
    
    private 泛型标识  变量名;
    
    ...
        
    ...
}


// 使用语法

类名<具体数据类型> 对象名  = new 类名<具体数据类型>（）；
    
jdk1.7以后，类型推断
类名<具体数据类型> 对象名  = new 类名<>（）；
 
    
// 1.泛型类使用的时候没有指定具体的数据类型的时候，将按照Object类型来接受的
// 2.泛型类不允许指定  基本数据类型    
```



**常用的泛型标识符:**

```java
T、E、K、V
```



### 泛型类定义

T,是由外部使用的时候所指定的

```java
public class GenericClazz<T> {

    private Integer number;

    private T t;

    public Integer getNumber() {
        return number;
    }

    public void setNumber(Integer number) {
        this.number = number;
    }

    public T getT() {
        return t;
    }

    public void setT(T t) {
        this.t = t;
    }

    @Override
    public String toString() {
        return "GenericClazz{" +
                "number=" + number +
                ", t=" + t +
                '}';
    }

    public static void main(String[] args) {

        GenericClazz<String> genericClazz = new GenericClazz<>();
        // 确定的数据类型
        genericClazz.setNumber(10);
        genericClazz.setT("外部使用的时候传入的类型");
        System.out.println(genericClazz);


        GenericClazz<String> clazz2 = new GenericClazz<>(100, "构造方法");

        // 未指定具体的类型，将按照Object来进行推断
        GenericClazz<Object> clazz3 = new GenericClazz<>();
        
    }
}
```



**注释：**

1. 常见的做法是类型变量使用大写字母，而且很简短。Java库使用变量E表示集合的元素类型，K和V分别表示表的键和值的类型。T表示任意类型（必要时和可以使用相邻的字母U和S)表示任意类型；
2. 泛型类使用的时候没有指定具体的数据类型的时候，将按照Object类型来接受的；
3. 泛型类使用时不允许指定  **基本数据类型**   。
4. 泛型类逻辑上可以看成的不同的类型，实际上都是相同类型，可以通过指定不同的数据类型进行内存地址的比较，发现指向是同一个内存地址

### 泛型类实战

构建商品抽奖器

```java
public class ProductGetter<T> {
    private final Random random = new Random();
    private final List<T> productList = new ArrayList<>();

    public void addProduct(T t){
        productList.add(t);
    }
    public T getRandomProduct(){

        return productList.get(random.nextInt(productList.size()));
    }
    public static void main(String[] args) {

        ProductGetter<String> productPool = new ProductGetter<>();

        String[] products = new String[]{"mac电脑","苹果手机iphone","华为phone",};

        for (String product : products) {

            productPool.addProduct(product);
        }
        String randomProduct = productPool.getRandomProduct();

        System.out.println(randomProduct);
        
    }
}
```



### 泛型类派生子类

- **如果子类也是泛型类，子类和父类的泛型要一致**

```java
// 如果子类是泛型类,父类没有明确泛型类,则重写父类方法的时候返回的是Object()类型
public class ChildGenericClazz<T> extends ParentGenericClazz{

    @Override
    public Object getStr1() {
        return super.getStr1();
    }
}

// 正确使用
public class ChildGenericClazz<T> extends ParentGenericClazz<T>{

    @Override
    public T getStr1() {
        return super.getStr1();
    }
}

```



- **子类不是泛型类，父类要明确具体的泛型的类型**



```java

// 子类和父类都不明确泛型类,则会导致子类和父类都会被当成普通类来出来
public class ChildGenericSecondClazz extends ChildGenericClazz {
   // 此处返回的是Object
    @Override
    public Object getStr2() {
        return super.getStr2();
    }
}


// 父类不明确具体的泛型类型的话会报错
public class ChildGenericSecondClazz extends ChildGenericClazz<String> {

    @Override
    public String getStr2() {
        return super.getStr2();
    }
}

```





#### 未完待续....泛型接口



